---
title: B-Tree 索引和 Hash 索引
date: 2020-02-23 11:04:40
tags: [MySQL]
categories: [数据库]
---

什么是 B-Tree 索引与 Hash 索引？

<!--more-->


# 索引

索引的定义： 存储引擎用于快速找到记录的一种数据结构。

假设数据库是一本书， 索引就是书中的目录， 能让我们更快的找到我们需要查询的内容。 如果没有目录我们需要把整本书翻一遍， 运气不好可能需要翻到最后一页才能找到我们需要查找的内容。

# 索引分类

## 按逻辑存储结构划分

* B树索引（按物理结构划分又可以分为聚簇索引和非聚簇索引）

* Hash 索引

* 空间索引

* 全文索引

## 建立在单列还是多列划分

* 单列索引

* 符合索引

## 约束条件划分

* 唯一索引

* 主键索引

接下来介绍常见的 B-Tree 索引和 Hash 索引

# B-Tree 索引

数据库采用 B-Tree 索引的原因很简单： **减少随机磁盘 IO 次数**。原因在于数据的量很大，大部分的数据都是存储在磁盘中， 不可能全部存储在内存中。

为什么说 B-Tree 索引更适合数据库存储数据， 咱们可以将 B-Tree 的结构和其他的数据结构做下对比， 以 B-Tree 与红黑树为例。

在这先看下红黑树与 B-树的特点：

* 红黑树
    1. 每个结点要么是红的，要么是黑的。
    2. 根结点是黑的。
    3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
    4. 如果一个结点是红的，那么它的俩个儿子都是黑的。
    5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
   
![红黑树](/black-tree.gif)

红黑树的特点使得红黑树不仅是棵平衡树， 而且比平衡树更加平衡， 读取数据的次数更少。


* B-树：是一种多路搜索树（并不是二叉的）
    1. 根结点至少有两个子节点。
    2. 每个中间节点(根节点和叶子节点除外)都包含k-1个元素和k个孩子节点，其中 m/2 <= k <= m 。m 代表树的高度， 也叫做阶。
    3. 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m。
    4. 所以的值都是按顺序存储的。
    5. 每个叶子页到根的距离相同。

![B-Tree](/b-tree.gif)


在对比时可以发现， 想要找到 008 的这个数， 在红黑树需要遍历三次， 而在 B-Tree 中只需要两次即可。当数据量越来越大时， B-Tree 会变的矮胖起来， 同样的数据量在 B-Tree 中需要查找的次数更少。对于相同的数据量，B树的更矮，高度更低，查找数据时经过的节点更少，所以造成的随机磁盘IO次数也就更少。(文件索引数据库索引用的都是B树)

# B+Tree

InnoDB引擎内部使用的是 B+Tree 作为索引的存储结构。

* 在进行数据查找时，通过比较 key 来找到对应的 value (也就是我们要查找的数据)。B树每个数据的 Key-Value 都是存储在一起的(实际上value部分只是存储了数据行的引用)，每次比较key的时候都会把 value 也给读取出来，这就造成了不必要的磁盘IO。

* 另外数据库经常会出现范围查询的需求，单纯的B树进行范围查询需要回溯到父节点，这也造成了大量的I/O操作，而且这个操作相当复杂。

为了解决这些问题B树的发明者对B树进行了一些改进。

B+树是B树的变体，它的完整数据全部存储在叶子结点，非叶子节点只存储key值，这样B+树避免了不必要的磁盘I/O，由于所有的查找最终都会到叶子结点，所以也就保证了查询性能的稳定。

同时由于B+树叶子结点使用指针串联起来，这就方便了范围查询(>、<、between等)。

而且由于B+树索引本身的有序性，所以在很多情况下可以避免对数据的排序(对磁盘排序要用到文件外排序，而且数据量很大很耗时)。

![B-Tree索引](/b-tree-index.jpg)

总结起来，使用B+树作为数据库索引的存储结构有以下原因：

* 减少磁盘I/O，并尽量避免不必要的磁盘I/O
* B+树保证了查询性能的稳定
* B+树方便范围查询
* 避免对数据进行外排序(filesort)

# 哈希索引
hash在很多编程语言中都能见到，因为它查找速度非常快，理论上平均时间复杂度能达到O(1)。 是 Memory引擎的默认索引。

存储引擎对每一列计算出一个哈希码，将其保存在哈希表中， 同时哈希表保存每行的指针, 如果出现 hash 碰撞， 索引会以链表的形式存放多个记录到同一条哈希目录上， 结构类似于 HashTable。

举个例子：

| name | age |
| --- | --- |
| Jane | 28 |
| Peter |  20|
| David |  30|

假设使用哈希函数f()，对每条记录生成哈希值：
f('Jane') = 2323
f('Peter') = 2456
f('David') = 2400

| 槽(slot) | 值（value) |
| --- | --- |
| 2323 | 第一行指针 |
| 2456 |  第三行指针 |
| 2400  |  第二行指针 |

看有hash 索引具体是如何工作的， 举个例子：

```java
select * from user where `name` = 'Jane'
```

执行上面这条 sql 语句会先计算 Jane 的哈希值， 然后根据哈希值 2323 对应的指针去找到对应的第一行数据。

![哈希索引](/hash-index.jpg)

单行查询的速度要比 B-Tree索引快很多，但hash索引在使用上有很大的局限性：

* 无序性，导致无法范围查找和索引排序。
* between, > 、<、等范围查询无法使用索引。
* 对完整的key计算hash，所以不支持部分匹配。
* 比如对多个列创建hash索引，查找时条件必须这些列精确匹配，才能使用到hash索引。都精确匹配了，更别谈什么索引覆盖。
* 再比如，使用like 'hash%'进行前缀匹配，也无法使用hash索引。
* 由于hash索引实际只保存了数据对应的行指针，所以不能避免读取数据行(说白了还是没有索引覆盖的功能)。
* 当产生hash碰撞(哈希值相同)的时候，数据库要遍历链表中所有的行指针，逐个取出数据行进行比较，数据量越大，冲突越多，查找代价越高。

由于hash索引的上述缺点，所以实际使用hash索引的情况很少，MySQL除了Memory存储引擎和NDB分布式存储引擎，其他大部分存储引擎默认使用B树索引。



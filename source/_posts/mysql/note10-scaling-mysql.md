---
title: MySQL 扩展
date: 2020-04-06 23:31:32
tags: [MySQL]
categories: [数据库]
---


当 MySQL 规模变的越来越大时， 如何保证高效且经济？

<!--more-->

# 可扩展性

可扩展性表明当需要增加资源以执行更多工作时系统能获得收益的同等提升。 缺乏扩展能力的系统达到收益递减的转折点后， 将无法进一步增长。

系统是否需要扩展一般从哪个四个因素进行衡量：
* 数据量
* 用户量
* 用户活跃度
* 相关数据集大小

增加服务器并不能完全增加系统的吞吐率， 大多数情况下都属于 USL 扩展

# 如何扩展 MySQL

MySQL 扩展通常分为"垂直"扩展和"水平"扩展。 垂直扩展就是增加更多的机器， 水平扩展是将任务拆分分配到多台机器上。

## 知晓系统的底线

* 应用的功能是否都开发完毕了？ 是否到了需要扩展的阶段了。
* 预期的最大负载是多少？
* 如果局部失效如何防范。

## 扩展前先优化

* 优化性能
* 升级硬件

## 向上扩展-垂直扩展

建议使用更新的 MySQL 版本， 最大的配置是 256G RAM， 32 核 CPU， 再之后收益就递减了。
但是向上扩展的开销太大了， 并不是很好的选择。


## 向外扩展-水平扩展

向外扩展可以分为三步：复制、拆分和数据分片

最简单的做法是通过复制将数据分发到多个服务器上， 通过备库进行读查询， 对以读为主的应用很有效。 此外常见的做法是工作负载到多个节点， 其中节点可能是一个服务器， 也可能是一个集群， 通常有以下几种：

* 一个主-主复制双机机构， 一个主动，一个被动；
* 一主多备
* 一个主动服务器，使用分布式复制设备作为备库
* 一个基于存储区域网络的集群

下面是一些不同的分布负载方案

### 按功能拆分

不同的节点执行不同的任务，比如门户网站将论坛、新闻、知识库等不同的功能所需的数据存在不同的数据库中。

此外也可以对单台服务器的数据进行划分， 前提是表与表之间不会进行关联操作。

实际上不能通过功能划分进行无限扩展， 当一个功能与单个 MySQL 绑定后就只能垂直扩展了。

### 数据分片

在扩展大型 MySQL 应用的方案中，数据分片是最通用且最成功的方法。在数据分片前需要考虑当前的应用是否需要分片， 比如正在搭建的博客网站， 预计有 1000 万用户，这个时候就算把所以用户数据放在内存中也是可行的， 但是当用户达到 5 亿时就可能需要对数据进行分片了。

如果在设计之初就已经预计到分片， 之后分片就会容易很多。

单台服务器的功能划分：

![单台机器](/单台机器.jpg)


继续演进， 通过用户 ID 对文章和内容进行分片：
![分布式存储](/分布式存储.jpg)

如果事先知道应用会扩展到很大规模且了解功能划分的局限性， 就可以跳过中间步骤， 直接从单个节点升级为分片数据存储。


### 选择分区键

数据分片的挑战在于查找与获取数据， 对经常查询的数据减少分片， 最关键的点在于为数据选择一个或多个分区键， 因为分区键决定了每一行分配在哪一个分片中。 当知道一个对象的分区键， 就知道了
* 应该从哪里存储数据
* 应该从哪里查询数据

一个好的分区键通常是数据库中一个非常重要的实体的主键， 例如通过用户 ID 来分割数据， 分片的单元就是用户。

选择分区键的时候尽可能选择能够避免跨分片查询的键， 同时也让分片足够小以免过大的数据导致问题。


### 多个分区键

复杂数据分区困难时， 会拥有多个分区键。 例如需要对博客的数据按照用户 ID 和 文章 ID 进行分片， 这样即可以根据用户 ID 获取该用户的所有文章， 还可以通过文章 ID 获取该文章的所有评论。 


### 跨分片查询

大多数分片应用都有一些查询需要对多个分片的数据进行聚合或关联操作。 例如获取当前网站最受欢迎的用户， 就需要把所有分片访问一遍， 实际上需要拆分成多条并行执行的查询， 每个分片执行一条。

在并行查询时， 某些语言比如PHP对并行支持的并不好， 会利用 C 或者 JAVA 写一个辅助应用来执行聚合查询

同样的， 使用汇总表也可以提升跨分片查询的效率， 可以遍历所有分片来生成汇总表并将结果在每个分片上冗余存储。 

### 分片与节点

分片和节点并不是一对一的关系， 尽可能让分片的大小小于节点的容量。

首先分片足够小便于管理， 使得数据的备份和恢复更加容易， 假设100 G 的数据， 分为 100 个 1G 的分片， 存储在单个节点上， 对数据加索引时， 单个100 G 的表的执行时间会比 100 个 1G 的分片执行的时间更长。 

其次， 小的分片更方便转移。

### 节点上部署分片

通常有一下几种方法部署数据分片：

* 每个分片使用单一数据库，且数据库名相同。对应的应用场景是多实例应用， 每个应用对应一个分片。

* 将多个分片的表放在一个数据库中， 每个表名包含分片号。

* 每个分片使用一个数据库， 数据库中包含所有应用需要的表， 库名中包含分片号但表名不包含分片号。 当应用连接到数据库病不指定数据库名时， 则无须为每个分片编写专门的查询。

* 每个分片使用一个数据库， 并在数据库名和表名包含分片号。

* 每个节点运行多个MySQL示例， 每个实例有一个或多个分片。


### 固定分配与动态分配

将数据分配到分片中有两种主要的做法： 固定分配和动态分配。两个方法都需要分区函数，行的分区键值作为输入，存储改行的分片作为输出。

固定分配的好处在于分区函数仅仅依赖于分区键的值， 这样做简单，开销低， 比如使用 CRC32() 做哈希， CRC32(111) % 100  = 81。 

动态分配将每个数据单元映射到一个分片， 假设数据表有 用户ID 与 分片 ID， 根据分区键（用户ID）就可以查到 分片号， 如果没有查到对应分片号， 可以选择将目标分片号与当前用户ID绑定或者延迟更新。

### 混合分配

混合使用固定分配和动态分配， 映射目录不大时， 动态分配很好胜任， 分片单元太多效果会变差。


### 显式分配

很少使用， 不适合在已有数据上分片。


### 重新均衡分片数据

在分片间移动数据达到负载均衡。例如需要升级硬件时， 将用户数据从旧分片转移到新分片上， 无需暂停整个分片的服务， 也无需将其设置为只读。 但是进行均衡分片时会影响到用户的使用。


### 生成全局唯一 ID

通常单一数据存储时使用 AUTO_INCREMENT 列来获取唯一 ID， 但是涉及到多台服务器时就不生效了， 此时需要生产全局的唯一 ID， 通常有以下几种做法：

使用 auto_increment_inncrement 和 auto_increment_offset

    假设两台服务器， 一个偏移量为 1，另一台偏移量为 2， 这样一台服务器始终包含偶数， 一台服务器始终包含奇数。需要仔细配置。

全局节点创建表：
    
    在一个全局数据库节点中创建一个包含 AUTO_INCREMENT 列的表， 通过这个表生成唯一的数字。
    
使用 memcached

    memcached的 api 有一个 incr()函数，自动增长一个数字并返回结果。memcached不具备持久性，重启后会初始化缓存的值会从磁盘中查询最大的值，过程慢切不能保证原子性。
    
批量分配数字

    从全局节点中请求一批数字。
    
使用复合值

    使用复合值作为唯一 ID。
    
使用 GUID 值

    使用 UUID() 函数生成全局唯一值

使用全局分配器产生唯一 ID 需要注意避免单点争用成为性能瓶颈。


### 分片工具

使用抽象层可以避免直接让应用访问多个数据源， 而是将数据源隐藏在抽象层，抽象层主要完成以下工作：

* 连接到正确的分片并进行查询
* 分布式一致性校验
* 跨分片结果集聚合
* 跨分片关联操作
* 锁和事务管理
* 创建新的数据分片

常见的分片工具有 Hibernnate Shards 和 HiveDB。

## 多实例扩展

不要在一台服务器上只运行一个服务器实例，让数据分片足够小， 使每台机器都能放置多个分片， 这是一种向上扩展和向外扩展的组合方案。 

## 通过集群扩展

对比 MySQL 与 NoSQL

### MySQL Cluster

MySQL Cluster 由 NDB 数据库和 MySQL 存储引擎组成。 其中 NDB 是一个分布式、具备容错性、非共享的数据库， 提供同步复制以及节点间的数据自动分片。 NDB 是一个键-值数据存储， 无法执行类似聚合或者联结操作。

### Clustrix
Clustrix 是一个分布式数据库， 支持 MySQL 协议， 它可以直接替代 MySQL， 支持 ACID， 支持 MVCC 的事务型SQL 的数据库。与MySQL Cluster 的不同点在于 Clustrix 是完全分布式且能兼容 MySQL 协议。

### ScaleBase

ScaleBase是一个代理器， 处于应用和多个后端 MySQL 服务器之间， 会把发起的查询进行分裂并将其分发到后端服务器并发执行， 然后汇总结果给应用。

### GenieDB

不支持 ACID， 最初用在地理上分布部署的 NoSQL 文档存储。

### Akiban

查询加速器， 存储物理数据来匹配查询模式， 可以进行低开销的跨表关联操作。


## 向内扩展

对不断增长的数据最简单的做法对不再需要的数据进行归档和清理， 设计和清理时需要考虑以下几点：

* 对应用的影响
* 要归档的行
* 维护数据的一致性
* 避免数据丢失
* 解除归档
















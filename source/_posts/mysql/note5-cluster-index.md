---
title: 聚簇索引、二级索引与覆盖索引
date: 2020-03-04 21:08:29
tags: [MySQL]
categories: [数据库]
---

聚簇索引到底是什么索引？ 覆盖索引又是怎么回事？

<!--more-->

# 聚簇索引
**定义**：

    聚簇索引并不是一种新数据结构， 而是 B-Tree 索引的一种存储方式，保存的是 B-Tree 索引和数据行。在 InnoDB 引擎下， 聚簇索引与主键索引是等价的。

* 当数据表定义主键时，InnoDB 使用主键做为聚簇索引；
* 如果表中未定义主键， MySQL 会自动选择第一个唯一索引 (UNIQUE INDEX)、且所在列 NOT NULL 时作为聚簇索引；
* 如果表中即未定义主键， 也没有合适的唯一索引， InnoDB会隐式地创建一个名为 **GEN_CLUST_INDEX** 的索引作为聚簇索引， 该索引包含了 6 个字节的 row id

**聚簇索引**结构如下， 同时也是 B+Tree 索引

![聚簇索引示例](/cluster_index.jpg)

**特性**：

* 数据行的逻辑顺序与聚簇索引的顺序一致，B+树中叶子结点以链表的形式串联的，叶子节点中数据行的逻辑顺序只有一种，所以一张表只能有一个聚簇索引。

* 叶子结点包含了数据行的完整数据，非叶子节点只包含索引列数据。

* 通过聚簇索引，能够更快地找到数据所在的页，如果表中数据很多，能够有效节省磁盘 IO 次数。

# 二级索引（非聚簇索引）

InnoDB 中除过主键索引， 其余的统称为二级索引，二级索引会在叶子节点保存主键。
当通过二级索引进行查找时， 二级索引会通过叶子结点找到主键， 然后再根据主键找到数据所在的行， 这样做的好处是减少了数据行移动和页分裂时二级索引的维护工作, 但是通过二级索引查找数据时相当于利用了两个 B 树, 要解决这种问题需要引入**覆盖索引**， 覆盖索引接下来我们会讲到。

![InnoDB 聚簇索引](/cluster_index.png) ![InnoDB 二级索引](/secondary_index.png)


在实际的查找过程如下：

![实际查找过程](/b-tree-index.jpg)

以 Tom 为例， 在二级索引key(b, c)中， 先找到 b = 22 and c = tom 的行， 同时得到row id = 30， 根据 row id 回到主键索引， 就能找到 row id = 30 的所有数据。

# 聚簇索引的优缺点

优点：

* 聚簇索引将索引与数据行保存在同一个 B-Tree 中， 查询通过聚簇索引就能够直接得到数据，而非聚簇索引则需要多次 IO， 所以聚簇索引的查询速度比非聚簇索引的速度更快；
* 聚簇索引对主键的范围查询效率很高， 因为聚簇索引的数据是按主键排列的；
* 覆盖索引扫描的查询可以直接使用页节点中的主键值。

缺点： 

* 聚簇索引的优势在于减少 IO， 如果查询的数据都在内存中那么对访问顺序就没那么重要了；
* 插入的速度严重依赖于插入的顺序，按主键的顺序插入是最快的，否则会出现页分裂这种情况。对于 InnoDB 引擎的表都会定义一个自增 id；
* 聚簇索引在更新和插入新的数据时，可能会导致页分裂的问题：当插入的已满的叶子节点时，B+树会分裂成两个页来容纳新增的数据。页分裂会导致表占用更多的磁盘空间；
* 聚簇索引会导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候（**所以不要使用 uuid 作为主键**）。
* 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。

# 覆盖索引

定义：

    覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也称之为索引覆盖。

举个例子, 此时 tb_user 中只有主键索引：

```java
-- 添加覆盖索引前
mysql> select count(name) from tb_user where name like 'jSMfqpA%';
+-------------+
| count(name) |
+-------------+
|           2 |
+-------------+
1 row in set (0.15 sec)  # 耗时 0.15 秒

-- 新增索引
mysql> create index idx_tb_user_name on tb_user(name);

+----------+------------+--------------------------------------------------------------+
| Query_ID | Duration   | Query                                                        |
+----------+------------+--------------------------------------------------------------+
|       10 | 0.00029900 | select count(name) from tb_user where name like 'jSMfqpA%'   |
+----------+------------+--------------------------------------------------------------+
```

name 字段新增索引后耗时 0.29 毫秒， 与之前无索引时性能差了近千倍。

对比下同样是有索引的字段， 但不是覆盖索引的查询：

```java
+----------+------------+--------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                              |
+----------+------------+--------------------------------------------------------------------+
|       16 | 0.00863500 | select count(name) from tb_user where birth > '2020-01-01'         |
+----------+------------+--------------------------------------------------------------------+
```

可以看到同样是索引的字段， 覆盖索引查询与非覆盖索引的查询也相差一个量级， 索引与非索引的查询性能更是相差千倍。

```java
mysql> explain select count(name) from tb_user where name like 'jSMfqpA%' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_user
   partitions: NULL
         type: range
possible_keys: idx_tb_user_name
          key: idx_tb_user_name
      key_len: 13
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using where; Using index  # 使用到索引查询且未覆盖索引
1 row in set, 1 warning (0.00 sec)


mysql> explain  select count(name) from tb_user where birth > '2020-01-01' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tb_user
   partitions: NULL
         type: range
possible_keys: idx_tb_user_birth
          key: idx_tb_user_birth
      key_len: 4
          ref: NULL
         rows: 2962
     filtered: 100.00
        Extra: Using index condition  # 使用到索引查询，但非覆盖索引
1 row in set, 1 warning (0.00 sec)
```


总结：

* 当一条查询语句符合覆盖索引条件时，MySQL 只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再回表查询，减少I/O提高效率。
* InnoDB使用聚集索引存储数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。


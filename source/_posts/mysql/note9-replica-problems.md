---
title: MySQL 复制存在的问题
date: 2020-03-28 12:13:27
tags: [MySQL]
categories: [数据库]
---

MySQL 复制存在哪些问题?

<!--more-->

# 复制的问题及解决方案
## 数据损坏或丢失
当服务器崩溃、掉电、磁盘损坏等情况下， MySQL 复制并不能很好的恢复。需要从某个节点开始重启复制。
一下是意外关闭服务器，没有把数据及时刷新到磁盘带来的复制问题：

* master 意外关闭
    如果没有设置master 的 sync_binlog 选项， master 崩溃前没有将最后的二进制日志文件刷新到磁盘中，slave 也会因为读不到尚未写入磁盘的事件。
    
* slave 意外关闭
    slave 意外关闭， 会去读 master.info 文件找到上次停止复制的位置， 但是该文件并没有同步写到磁盘，存储的信息就是错的。
    
* master 的二进制文件损坏
    
* slave 的中继日志损坏

* 二进制日志与 InnoDB 事务日志不同步

* 数据改变，事件仍是有效的 SQL

* 数据改变且事件是无效的SQL

* 数据遗漏且事件的长度是错误的

* 某些事件已经损坏，或者偏移量也是错的

## 使用非事务型表

非事务型表更新发送错误时，可能会导致 master 和 slave 的数据不一致， 例如在查询过程中被 kill。如果是使用 MyISAM 表， 关闭 MySQL 之前需要确保已经运行了 STOP SLAVE。

## 混合事务型和非事务型表

如果混合使用了事务型和非事务型表， 发生回滚时， MySQL 会回滚事务型表的更新， 但非事务型表则被永久地更新了。此时日志会记录一条 ROLLBACK 语句到日志中， 同样的语句也会在 slave 执行。
一般不要事务型表与非事务型表进行混用。除非是基于行的复制

## 不确定的语句

基于语句的复制， 当通过不确定的方式更改数据也会导致主备不一致。 比如 LIMIT..UPDTAE 进行更新数据， 取决于查找行的顺序， 除非能保证主备库上的顺序是相同的。

## 主备间使用了不同的存储引擎

主备使用不同的存储引擎时， 基于语句的复制可能会造成主备上执行相同的语句得到的结果不同

## 备库数据发送改变

备库数据发送改表时， 执行：
INSERT INTO tb1 SELECT * FROM tb2;
会导致主备数据不一致。

## 不唯一的服务器 ID

不小心将两台服务器设置了相同的服务器 ID， 在主库上回发现两台备库只有一台连接到了主库， 在备库的错误日志中会发现反复的重连和断开信息。


## 未定义的服务器 ID

如果没有在 my.cnf 中定义服务器 ID， 可以通过 CHANGE MASTER TO 设置备库，但是无法启动复制， 因为没有显式的为当前服务器设置服务器 ID。

## 对未复制数据的依赖性

避免主库上创建备库不存在的表。

## 丢失的临时表

临时表与基于语句复制的方式是不相容的， 当备库崩溃或者正常关闭时， 复制线程用于的临时表会丢失， 而依赖于临时表的语句都会失败。

## 不复制索引的更新

错误地使用 SET SQL_LOG_BIN = 0 或者没有理解过滤规则， 备库可能会丢失主库上已经发生的更新。

## InnoDB 加锁读引起的锁竞争

正常情况下， InnoDBd 读操作是非阻塞的， 但是在基于语句复制的方式下，执行 INSERT...SELECT会锁定表上的所有行。加锁会导致主库上的语句串行化， 以确保和备库上的执行方式相符。
第一种缓解方法， 在主库尽快地提交事务以释放锁。
另外一种替换 INSERT...SELECT语句， 在主库先执行 SELECT INTO OUTFILE, 再执行 LOAD DATA INFILE， 这种方法更快且不需要加锁

## 主-主模式下写入数据到两台主库

之前有提到过使用 AUTO_INCREMENT 自增主键解决自增列冲突问题。但自增主键也会带来一些其他的问题:
* 很难再复制拓扑间做故障转移
* 数字之间有间隙， 会引起键空间浪费
* 很多时候并不会使用 AUTO_INCREMENT 作为主键

替代方法有使用 serverId 作为主键， 对 serverId 进行位运算, 可以采用 MD5()或者 UUID()等函数获取伪随机数

## 过大的复制延迟

复制产生延迟一般有两种方式： 突然产生延迟再跟上（通常是由于一条运行很长时间的查询导致的）， 或者稳定的延迟增大。

为了避免过大的延迟， 有以下措施：
* 不要重复写操作中代价较高的部分
* 复制之外并行写入
* 为复制线程预取缓存

## 来自主库过大的包

主库的 max_allowd_packet 的值与备库的值不匹配

## 受限制的复制带宽

使用受限的带宽进行复制， 可以开启备库的 slave_compressed_protocol 选项。

## 磁盘空间不足

当二进制日志、中继日志或临时文件将磁盘撑满，尤其是主库执行了 LOAD DATA INFILE 查询并在备库开启了 log_slave_updates。 延迟越严重，接收到尚未执行的中继日志就越多，占用的磁盘空间也越大。 可以通过监控磁盘并设置 relay_log_space 避免这种问题。

## 复制的局限性

大量的SQL 函数和编程不能被可靠的复制（基于语句的复制), 很难确保代码中不会出现这样的问题。 
另一个局限性是服务器的 bug， 大多数 MySQL 都存储历史遗留的复制 bug。


